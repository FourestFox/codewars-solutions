'''Информация по всем функциям'''
'''
Стартовая информация о Flask:
https://proglib.io/p/samouchitel-po-python-dlya-nachinayushchih-chast-23-osnovy-veb-razrabotki-na-flask-2023-06-27
https://pythonru.com/uroki/3-osnovy-flask
'''

'''
Инфо по модулям:
1) tkinter

2) random

3) time

4) datetime

5) typing

6) re (отдельный блок ниже)
'''

'''
Изменяемость коллекций

dict - изменяемое
list - изменяемое
set - изменяемое
frozenset - неизменяемое
tuple - неизменяемое
string - неизменяемое
'''

'''
Преобразование типов

1) bool(x) - преобразование к типу bool, использующая стандартную процедуру проверки истинности.
Если х является ложным или опущен, возвращает значение False, в противном случае она возвращает True.

2) bytearray([источник [, кодировка [ошибки]]]) - преобразование к bytearray. Bytearray - изменяемая последовательность 
целых чисел в диапазоне 0≤X<256. Вызванная без аргументов, возвращает пустой массив байт.

3) bytes([источник [, кодировка [ошибки]]]) - возвращает объект типа bytes, который является неизменяемой 
последовательностью целых чисел в диапазоне 0≤X<256. Аргументы конструктора интерпретируются как для bytearray().

4) complex([real[, imag]]) - преобразование к комплексному числу.

5) dict([object]) - преобразование к словарю.

6) float([X]) - преобразование к числу с плавающей точкой. Если аргумент не указан, возвращается 0.0.

7) frozenset([последовательность]) - возвращает неизменяемое множество.

8) int([object], [основание системы счисления]) - преобразование к целому числу.

9) list([object]) - создает список.

10) memoryview([object]) - создает объект memoryview.

11) object() - возвращает безликий объект, являющийся базовым для всех объектов.

12) range([start=0], stop, [step=1]) - арифметическая прогрессия от start до stop с шагом step.

13) set([object]) - создает множество.

14) slice([start=0], stop, [step=1]) - объект среза от start до stop с шагом step.

15) str([object], [кодировка], [ошибки]) - строковое представление объекта. Использует метод __str__.

16) tuple(obj) - преобразование к кортежу.
'''

'''
Другие встроенные функции

1) abs(x) - Возвращает абсолютную величину (модуль числа).

2) all(последовательность) - Возвращает True, если все элементы истинные (или, если последовательность пуста).

3) any(последовательность) - Возвращает True, если хотя бы один элемент - истина. 
Для пустой последовательности возвращает False.

4) ascii(object) - Как repr(), возвращает строку, содержащую представление объекта, 
но заменяет не-ASCII символы на экранированные последовательности.

5) bin(x) - Преобразование целого числа в двоичную строку.

6) callable(x) - Возвращает True для объекта, поддерживающего вызов (как функции).

7) chr(x) - Возвращает односимвольную строку, код символа которой равен x.

8) classmethod(x) - Представляет указанную функцию методом класса.

9) compile(source, filename, mode, flags=0, dont_inherit=False) - Компиляция в программный код, 
который впоследствии может выполниться функцией eval или exec. Строка не должна содержать символов возврата каретки 
или нулевые байты.

10) delattr(object, name) - Удаляет атрибут с именем 'name'.

11) dir([object]) - Список имен объекта, а если объект не указан, список имен в текущей локальной области видимости.

12) divmod(a, b) - Возвращает частное и остаток от деления a на b.

13) enumerate(iterable, start=0) - Возвращает итератор, при каждом проходе предоставляющем кортеж из номера и 
соответствующего члена последовательности.

14) eval(expression, globals=None, locals=None) - Выполняет строку программного кода.

15) exec(object[, globals[, locals]]) - Выполняет программный код на Python.

16) filter(function, iterable) - Возвращает итератор из тех элементов, для которых function возвращает истину.

17) format(value[,format_spec]) - Форматирование (обычно форматирование строки).

18) getattr(object, name ,[default]) - извлекает атрибут объекта или default.

19) globals() - Словарь глобальных имен.

20) hasattr(object, name) - Имеет ли объект атрибут с именем 'name'.

21) hash(x) - Возвращает хеш указанного объекта.

22) help([object]) - Вызов встроенной справочной системы.

23) hex(х) - Преобразование целого числа в шестнадцатеричную строку.

24) id(object) - Возвращает "адрес" объекта. Это целое число, которое гарантированно будет уникальным и постоянным для 
данного объекта в течение срока его существования.

25) input([prompt]) - Возвращает введенную пользователем строку. Prompt - подсказка пользователю.

26) isinstance(object, ClassInfo) - Истина, если объект является экземпляром ClassInfo или его подклассом. Если объект 
не является объектом данного типа, функция всегда возвращает ложь.

27) issubclass(класс, ClassInfo) - Истина, если класс является подклассом ClassInfo. Класс считается подклассом себя.

28) iter(x) - Возвращает объект итератора.

29) len(x) - Возвращает число элементов в указанном объекте.

30) locals() - Словарь локальных имен.

31) map(function, iterator) - Итератор, получившийся после применения к каждому элементу последовательности функции 
function.

32) max(iter, [args ...] * [, key]) - Максимальный элемент последовательности.

33) min(iter, [args ...] * [, key]) - Минимальный элемент последовательности.

34) next(x) - Возвращает следующий элемент итератора.

35) oct(х) - Преобразование целого числа в восьмеричную строку.

36) open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True) - Открывает файл и 
возвращает соответствующий поток.

37) ord(с) - Код символа.

38) pow(x, y[, r]) - ( x ** y ) % r.

39) reversed(object) - Итератор из развернутого объекта.

40) repr(obj) - Представление объекта.

41) print([object, ...], *, sep=" ", end='\n', file=sys.stdout) - Печать.

42) property(fget=None, fset=None, fdel=None, doc=None)

43) round(X [, N]) - Округление до N знаков после запятой.

44) setattr(объект, имя, значение) - Устанавливает атрибут объекта.

45) sorted(iterable[, key][, reverse]) - Отсортированный список.

46) staticmethod(function) - Статический метод для функции.

47) sum(iter, start=0) - Сумма членов последовательности.

48) super([тип [, объект или тип]]) - Доступ к родительскому классу.

49) type(object) - Возвращает тип объекта.

50) type(name, bases, dict) - Возвращает новый экземпляр класса name.

51) vars([object]) - Словарь из атрибутов объекта. По умолчанию - словарь локальных имен.

52) zip(*iters) - Итератор, возвращающий кортежи, состоящие из соответствующих элементов аргументов-последовательностей.
'''

'''
Функции/методы строк

1) S = "s\np\ta\nbbb" - Экранированные последовательности

2) S = r"C:\temp\new" - Неформатированные строки (подавляют экранирование)

3) S = b"byte" - Строка байтов

4) S1 + S2 - Конкатенация (сложение строк)

5) S1 * 3 - Повторение строки

6) S[i] - Обращение по индексу

7) S[i:j:step] - Извлечение среза

8) len(S) - Длина строки

9) S.find(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер первого вхождения или -1

10) S.rfind(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер последнего вхождения или -1

11) S.index(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError

12) S.rindex(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает 
ValueError

13) S.replace(шаблон, замена[, maxcount]) - Замена шаблона на замену. maxcount ограничивает количество замен

14) S.split(символ) - Разбиение строки по разделителю

15) S.isdigit() - Состоит ли строка из цифр

16) S.isalpha() - Состоит ли строка из букв

17) S.isalnum() - Состоит ли строка из цифр или букв

18) S.islower() - Состоит ли строка из символов в нижнем регистре

19) S.isupper() - Состоит ли строка из символов в верхнем регистре

20) S.isspace() - Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), 
"новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))

21) S.istitle() - Начинаются ли слова в строке с заглавной буквы

22) S.upper() - Преобразование строки к верхнему регистру

23) S.lower() - Преобразование строки к нижнему регистру

24) S.startswith(str) - Начинается ли строка S с шаблона str

25) S.endswith(str) - Заканчивается ли строка S шаблоном str

26) S.join(список) - Сборка строки из списка с разделителем S

27) ord(символ) - Символ в его код ASCII

28) chr(число) - Код ASCII в символ

29) S.capitalize() - Переводит первый символ строки в верхний регистр, а все остальные в нижний

30) S.center(width, [fill]) - Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)

31) S.count(str, [start],[end]) - Возвращает количество непересекающихся вхождений подстроки 
в диапазоне [начало, конец] (0 и длина строки по умолчанию)

32) S.expandtabs([tabsize]) - Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими 
пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам

33) S.lstrip([chars]) - Удаление пробельных символов в начале строки

34) S.rstrip([chars]) - Удаление пробельных символов в конце строки

35) S.strip([chars]) - Удаление пробельных символов в начале и в конце строки

36) S.partition(шаблон) - Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. 
Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки

37) S.rpartition(sep) - Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона.
Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку

38) S.swapcase() - Переводит символы нижнего регистра в верхний, а верхнего – в нижний

39) S.title() - Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

40) S.zfill(width) - Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями

41) S.ljust(width, fillchar=" ") - Делает длину строки не меньшей width, по необходимости заполняя последние символы 
символом fillchar

42) S.rjust(width, fillchar=" ") - Делает длину строки не меньшей width, по необходимости заполняя первые символы 
символом fillchar

43) S.format(*args, **kwargs) - Форматирование строки (f'строка {что вставить}' - так удобнее)
'''

'''
Функции/методы чисел

x + y - Сложение

x - y - Вычитание

x * y - Умножение

x / y - Деление

x // y - Получение целой части от деления

x % y - Остаток от деления

-x - Смена знака числа

abs(x) - Модуль числа

divmod(x, y) - Пара (x // y, x % y)

x ** y - Возведение в степень

pow(x, y[, z]) - xy по модулю (если модуль задан)
--------------------------------------------------------
Битовые операции
x | y - Побитовое или

x ^ y - Побитовое исключающее или

x & y - Побитовое и

x << n - Битовый сдвиг влево

x >> y - Битовый сдвиг вправо

~x - Инверсия битов
--------------------------------------------------------
Дополнительные методы
int.bit_length() - количество бит, необходимых для представления числа в двоичном виде, без учёта знака и 
лидирующих нулей.

int.to_bytes(length, byteorder, *, signed=False) - возвращает строку байтов, представляющих это число.

classmethod int.from_bytes(bytes, byteorder, *, signed=False) - возвращает число из данной строки байтов.
-------------------------------------------------------
Системы счисления

int([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. 
По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.

bin(x) - преобразование целого числа в двоичную строку.

hex(х) - преобразование целого числа в шестнадцатеричную строку.

oct(х) - преобразование целого числа в восьмеричную строку.
----------------------------------------------------------
Вещественные числа (float)
float.as_integer_ratio() - пара целых чисел, чьё отношение равно этому числу.

float.is_integer() - является ли значение целым числом.

float.hex() - переводит float в hex (шестнадцатеричную систему счисления).

classmethod float.fromhex(s) - float из шестнадцатеричной строки.

'''

'''
Функции/методы списков
Важно: методы списков, в отличие от строковых методов, изменяют сам список, а потому результат выполнения не нужно 
записывать в эту переменную.

1) list.append(x) - Добавляет элемент в конец списка

2) list.extend(L) - Расширяет список list, добавляя в конец все элементы списка L

3) list.insert(i, x) - Вставляет на i-ый элемент значение x

4) list.remove(x) - Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует

5) list.pop([i]) - Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент

6) list.index(x, [start [, end]]) - Возвращает положение первого элемента со значением x 
(при этом поиск ведется от start до end)

7) list.count(x) - Возвращает количество элементов со значением x

8) list.sort([key=функция]) - Сортирует список на основе функции

9) list.reverse() - Разворачивает список

10) list.copy() - Поверхностная копия списка

11) list.clear() - Очищает список
'''

'''
Функции/методы словарей

1) dict.clear() - очищает словарь.

2) dict.copy() - возвращает копию словаря.

3) classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

4) dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, 
а возвращает default (по умолчанию None).

5) dict.items() - возвращает пары (ключ, значение).

6) dict.keys() - возвращает ключи в словаре.

7) dict.pop(key[, default]) - удаляет ключ и возвращает значение. 
Если ключа нет, возвращает default (по умолчанию бросает исключение).

8) dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. 
Помните, что словари неупорядочены.

9) dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, 
а создает ключ со значением default (по умолчанию None).

10) dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. 
Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

11) dict.values() - возвращает значения в словаре.
'''

'''
Функции/методы множеств
Важно: Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет. 
Примерно похожая ситуация с списками и кортежами.

1) len(s) - число элементов в множестве (размер множества).

2) x in s - принадлежит ли x множеству s.

3) set.isdisjoint(other) - истина, если set и other не имеют общих элементов.

4) set == other - все элементы set принадлежат other, все элементы other принадлежат set.

5) set.issubset(other) или set <= other - все элементы set принадлежат other.

6) set.issuperset(other) или set >= other - аналогично.

7) set.union(other, ...) или set | other | ... - объединение нескольких множеств.

8) set.intersection(other, ...) или set & other & ... - пересечение.

9) set.difference(other, ...) или set - other - ... - множество из всех элементов set, 
не принадлежащие ни одному из other.

10) set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, 
но не встречающиеся в обоих.

11) set.copy() - копия множества.

Операции, непосредственно изменяющие множество:

1) set.update(other, ...); set |= other | ... - объединение.

2) set.intersection_update(other, ...); set &= other & ... - пересечение.

3) set.difference_update(other, ...); set -= other | ... - вычитание.

4) set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, 
но не встречающиеся в обоих.

5) set.add(elem) - добавляет элемент в множество.

6) set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.

7) set.discard(elem) - удаляет элемент, если он находится в множестве.

8) set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, 
какой элемент будет первым.

9) set.clear() - очистка множества.
'''

'''
Регулярные выражения (регексы) (https://habr.com/ru/articles/349860/)
Метасимволы/шаблоны:

1) . - Один любой символ, кроме новой строки \n.

2) \d - Любая цифра

3) \D - Любой символ, кроме цифры

4) \s - Любой пробельный символ (пробел, табуляция, конец строки и т.п.)

5) \S - Любой непробельный символ

6) \w - Любая буква (то, что может быть частью слова), а также цифры и _

7) \W - Любая не-буква, не-цифра и не подчёркивание

8) [..] - Один из символов в скобках, а также любой символ из диапазона a-b

9) [^..] - Любой символ, кроме перечисленных

10) \d≈[0-9], \D≈[^0-9], \w≈[0-9a-zA-Z а-яА-ЯёЁ], \s≈[ \f\n\r\t\v] - Буква “ё” не включается в общий диапазон букв!
Вообще говоря, в \d включается всё, что в юникоде помечено как «цифра», а в \w — как буква. Ещё много всего!

11) [abc-], [-1] - если нужен минус, его нужно указать последним или первым

12) [*[(+\\\]\t] - внутри скобок нужно экранировать только ] и \

13) \b - Начало или конец слова (слева пусто или не-буква, справа буква и наоборот).
В отличие от предыдущих соответствует позиции, а не символу 

14) \B - Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы
-----------------------------------------------------------------------------------------------------------------------
Квантификаторы (указание количества повторений)

1) {n} - Ровно n повторений

2) {m,n} - От m до n повторений включительно

3) {m,} - Не менее m повторений

4) {,n} - Не более n повторений

5) ? - Ноль или одно вхождение, синоним {0,1}

6) * - Ноль или более, синоним {0,}

7) + - Одно или более, синоним {1,}

8) *?, +?, ??, {m,n}?, {,n}?, {m,}? - По умолчанию квантификаторы жадные — захватывают максимально возможное 
число символов. Добавление ? делает их ленивыми, они захватывают минимально возможное число символов.
-----------------------------------------------------------------------------------------------------------------------
Функции/методы модуля re

1) re.search(pattern, string) - Найти в строке string первую строчку, подходящую под шаблон pattern;

2) re.fullmatch(pattern, string) - Проверить, подходит ли строка string под шаблон pattern;

3) re.split(pattern, string, maxsplit=0) - Аналог str.split(), только разделение происходит по подстрокам, 
подходящим под шаблон pattern;

4) re.findall(pattern, string) - Найти в строке string все непересекающиеся шаблоны pattern;

5) re.finditer(pattern, string) - Итератор по всем непересекающимся шаблонам pattern в строке string 
(выдаются match-объекты);

6) re.sub(pattern, repl, string, count=0) - Заменить в строке string все непересекающиеся шаблоны pattern на repl;
-----------------------------------------------------------------------------------------------------------------------
Пример использования всех основных функций
import re 

match = re.search(r'\d\d\D\d\d', r'Телефон 123-12-12') 
print(match[0] if match else 'Not found') 
# -> 23-12 

match = re.search(r'\d\d\D\d\d', r'Телефон 1231212') 
print(match[0] if match else 'Not found') 
# -> Not found 

match = re.fullmatch(r'\d\d\D\d\d', r'12-12') 
print('YES' if match else 'NO') 
# -> YES 

match = re.fullmatch(r'\d\d\D\d\d', r'Т. 12-12') 
print('YES' if match else 'NO') 
# -> NO 

print(re.split(r'\W+', 'Где, скажите мне, мои очки??!')) 
# -> ['Где', 'скажите', 'мне', 'мои', 'очки', ''] 

print(re.findall(r'\d\d\.\d\d\.\d{4}', 
                 r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> ['19.01.2018', '01.09.2017'] 

for m in re.finditer(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'): 
    print('Дата', m[0], 'начинается с позиции', m.start()) 
# -> Дата 19.01.2018 начинается с позиции 20 
# -> Дата 01.09.2017 начинается с позиции 45 

print(re.sub(r'\d\d\.\d\d\.\d{4}', 
             r'DD.MM.YYYY', 
             r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> Эта строка написана DD.MM.YYYY, а могла бы и DD.MM.YYYY 
-----------------------------------------------------------------------------------------------------------------------
Использование дополнительных флагов в питоне
Каждой из функций, перечисленных выше, можно дать дополнительный параметр flags, что несколько изменит режим работы 
регулярок. В качестве значения нужно передать сумму выбранных констант, вот они:

1) re.ASCII - По умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуютвсе юникодные символы с соответствующим 
качеством. Например, \d соответствуют не только арабские цифры, но и вот такие: ٠١٢٣٤٥٦٧٨٩. re.ASCII ускоряет работу,
если все соответствия лежат внутри ASCII.

2) re.IGNORECASE - Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно

3) re.MULTILINE - Специальные символы ^ и $ соответствуют началу и концу каждой строки

4) re.DOTALL - По умолчанию символ \n конца строки не подходит под точку. С этим флагом точка — вообще любой символ.

Пример:

import re 
print(re.findall(r'\d+', '12 + ٦٧')) 
# -> ['12', '٦٧']

print(re.findall(r'\w+', 'Hello, мир!')) 
# -> ['Hello', 'мир'] 

print(re.findall(r'\d+', '12 + ٦٧', flags=re.ASCII)) 
# -> ['12'] 

print(re.findall(r'\w+', 'Hello, мир!', flags=re.ASCII)) 
# -> ['Hello'] 

print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя')) 
# -> ['ааааа', 'яяяя'] 

print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя', flags=re.IGNORECASE)) 
# -> ['ОООО', 'ааааа', 'ЫЫЫЫ', 'яяяя'] 

text = r""" 
Торт 
с вишней1 
вишней2 
""" 
print(re.findall(r'Торт.с', text)) 
# -> [] 

print(re.findall(r'Торт.с', text, flags=re.DOTALL)) 
# -> ['Торт\nс'] 

print(re.findall(r'виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней1', 'вишней2'] 

print(re.findall(r'^виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней2'] 
-----------------------------------------------------------------------------------------------------------------------
Примеры простых регексов:
1) simple text - В точности текст «simple text»
2) \d{5} -  Последовательности из 5 цифр. \d означает любую цифру, {5} — ровно 5 раз
3) \d\d/\d\d/\d{4} - Даты в формате ДД/ММ/ГГГГ (и прочие куски, на них похожие, например, 98/76/5432)
4) \b\w{3}\b - Слова в точности из трёх букв. \b означает границу слова (с одной стороны буква, а с другой — нет)
\w — любая буква, {3} — ровно три раза
5) [-+]?\d+ - Целое число, например, 7, +17, -42, 0013 (возможны ведущие нули) [-+]? — либо -, либо +, либо пусто
\d+ — последовательность из 1 или более цифр
6) [-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)? - Действительное число, возможно в экспоненциальной записи
Например, 0.2, +5.45, -.4, 6e23, -3.17E-14.
'''